{"stonecutter.gradle.kts":"import org.gradle.api.DefaultTask\nimport org.gradle.api.tasks.Input\nimport org.gradle.api.tasks.TaskAction\nimport org.gradle.process.ExecOperations\nimport java.io.ByteArrayOutputStream\nimport java.io.File\nimport java.text.SimpleDateFormat\nimport java.util.Date\nimport javax.inject.Inject\n\nplugins {\n    id(\"dev.kikugie.stonecutter\") version \"0.7.10\"\n    id(\"dev.architectury.loom\") version \"1.11-SNAPSHOT\" apply false\n    id(\"me.modmuss50.mod-publish-plugin\") version \"0.5.+\" apply false\n    id(\"architectury-plugin\") version \"3.4-SNAPSHOT\" apply false\n    id(\"com.dorongold.task-tree\") version \"4.0.1\"\n}\n\n// $start stonecutter-active\n// $end stonecutter-active\n\nabstract class RunClientForVersionTask\n    @Inject\n    constructor(\n        private val execOperations: ExecOperations,\n    ) : DefaultTask() {\n        @get:Input\n        var version: String = \"\"\n\n        @get:Input\n        var isFirstRun: Boolean = false\n\n        init {\n            group = \"eternal-impl\"\n        }\n\n        @TaskAction\n        fun runClient() {\n            val taskPath = \":$version:runClient\"\n\n            val sharedLogDir =\n                project.layout.buildDirectory\n                    .dir(\"logs\")\n                    .get()\n                    .asFile\n            if (!sharedLogDir.exists()) {\n                sharedLogDir.mkdirs()\n            }\n\n            val subLogDir =\n                project.layout.buildDirectory\n                    .dir(\"../versions/$version/build/logs\")\n                    .get()\n                    .asFile\n            if (!subLogDir.exists()) {\n                subLogDir.mkdirs()\n            }\n\n            if (isFirstRun) {\n                project.logger.lifecycle(\"Performing initial log directory cleanup.\")\n                for (file in sharedLogDir.listFiles() ?: emptyArray()) {\n                    val fileName = file.name\n                    if (fileName.contains(\"latest_\")) {\n                        val newFileName = fileName.substring(7)\n                        project.logger.lifecycle(\"Renamed $fileName to $newFileName\")\n                        file.renameTo(File(sharedLogDir, newFileName))\n                    }\n                }\n            }\n            for (file in subLogDir.listFiles() ?: emptyArray()) {\n                val fileName = file.name\n                if (fileName.contains(\"latest_\")) {\n                    val newFileName = fileName.substring(7)\n                    project.logger.lifecycle(\"Renamed $fileName to $newFileName\")\n                    file.renameTo(File(subLogDir, newFileName))\n                }\n            }\n\n            val timestamp = SimpleDateFormat(\"yyyy.MM.dd_HH.mm.ss\").format(Date())\n            val currentLogFileName = \"latest_runClient_${version}_$timestamp.log\"\n            val actualSharedLogFile = File(sharedLogDir, currentLogFileName)\n\n            project.logger.lifecycle(\"--- Starting client task: $taskPath ---\")\n            project.logger.lifecycle(\"--- Logging output to: ${actualSharedLogFile.absolutePath} ---\")\n\n            val outputStream = ByteArrayOutputStream()\n            val errorStream = ByteArrayOutputStream()\n\n            try {\n                execOperations\n                    .exec {\n                        workingDir = project.rootDir\n                        commandLine(\n                            \"${project.gradle.gradleHomeDir}/bin/gradle\",\n                            taskPath,\n                            \"--console=plain\",\n                            \"--info\",\n                            \"--stacktrace\",\n                        )\n                        standardOutput = outputStream\n                        errorOutput = errorStream\n                        isIgnoreExitValue = true\n                    }.assertNormalExitValue()\n\n                actualSharedLogFile.writeBytes(outputStream.toByteArray())\n                if (errorStream.size() > 0) {\n                    actualSharedLogFile.appendBytes(\"\\n--- ERROR OUTPUT ---\\n\".toByteArray())\n                    actualSharedLogFile.appendBytes(errorStream.toByteArray())\n                }\n\n                project.logger.lifecycle(\"--- Finished client task: $taskPath successfully ---\")\n            } catch (e: Exception) {\n                actualSharedLogFile.writeBytes(outputStream.toByteArray())\n                if (errorStream.size() > 0) {\n                    actualSharedLogFile.appendBytes(\"\\n--- ERROR OUTPUT ---\\n\".toByteArray())\n                    actualSharedLogFile.appendBytes(errorStream.toByteArray())\n                }\n                project.logger.error(\"Client '$taskPath' failed or exited with an error: ${e.message}\")\n            }\n\n            File(subLogDir, currentLogFileName).writeBytes(actualSharedLogFile.readBytes())\n        }\n    }\n\nvar lastRunTaskName: String? = null\nvar taskCounter = 0\nval totalTaskCount = stonecutter.versions.size\n\nfor (stonecutterVersion in stonecutter.versions.map { ver -> ver.project }) {\n    val isFirst = taskCounter == 0\n    taskCounter++\n    val currentTaskName = \"runAllClientsSequentially $stonecutterVersion ($taskCounter-$totalTaskCount)\"\n\n    val realLastTaskName = lastRunTaskName\n    val lastTask = if (realLastTaskName == null) null else tasks.named(realLastTaskName)\n\n    tasks.register<RunClientForVersionTask>(currentTaskName) {\n        group = \"eternal-impl\"\n        version = stonecutterVersion\n        isFirstRun = isFirst\n\n        if (lastTask != null) {\n            dependsOn(lastTask)\n        }\n    }\n    lastRunTaskName = currentTaskName\n}\n\nif (lastRunTaskName != null) {\n    tasks.register(\"runAllClientsSequentially\") {\n        group = \"eternal\"\n        description = \"Runs all Minecraft clients for all Stonecutter versions sequentially.\"\n        dependsOn(tasks.named(lastRunTaskName!!))\n    }\n}\n","gradle.properties":"# When declaring a String list use spaces between values I.E: value1 value2 value3 value4 ...\n# Note: Some string lists have optional parameters, use \"UNSET\" to denote them.\n\n# Done to increase the memory available to gradle.\norg.gradle.jvmargs=-Xmx3G\norg.gradle.parallel=true\n\n# Basic gradle constants, should match the src directory.\n# Defaults to mod.id\narchives_base_name = UNSET\n# Defaults to com.[authors]\ngroup = UNSET\nversion = 0.0.1\n\n# Display name is for user display, id is for programmatic identification.\n# $start config-name\nmod.display_name = Example Mod\n# $end config-name\n# $start config-id\nmod.id = example_mod\n# $end config-id\n# $start config-class\nmod.class_name = ExampleMod\n# $end config-class\n\n# Edit these to fit your mod\n# $start config-license\nmod.license = MIT\n# $end config-license\n# $start config-description\nmod.description = TODO! TODO! TODO!\n# $end config-description\n# $start config-author\nmod.authors = author\n# $end config-author\nmod.source_url=https://github.com/Jacks-underscore-username/Eternal-Template-Generator\nmod.issue_tracker=https://github.com/Jacks-underscore-username/Eternal-Template-Generator/issues\nmod.icon=icon.png\n# Will use source_url by default\nmod.general_website=UNSET\n\n# When true mixins.${id}.json will be included in the resulting jar.\nmixins.vanilla.enable = true\n# When true mixins.fabric.${id}.json will be included in the resulting jar.\nmixins.fabric.enable = false\n# When true mixins.forge.${id}.json will be included in the resulting jar.\nmixins.forge.enable = false\n# When true mixins.neoforge.${id}.json will be included in the resulting jar.\nmixins.neoforge.enable = false\n# Includes extra mixins if specified, must be in String list format\nmixins.extras = UNSET\n\n# Core dependency versions\n# These are critical by mod loader.\n\n# This is a Version Range, a 1-2 argument String List where arg0 is the minimum version and arg1 is the maximum. The maximum version can be UNSET\n# Version range minimum will be used as the dev-env version.\ndeps.core.mc.version_range=[VERSIONED]\n\n# Version ranges are INCLUSIVE! The minimum version must be set, this is the value used to retrieve the dependency from network.\n// $start config-fabric-range\ndeps.core.fabric.loader.version_range= [VERSIONED]\n// $end config-fabric-range\ndeps.core.forge.version_range=[VERSIONED]\ndeps.core.neoforge.version_range=[VERSIONED]\ndeps.core.neoforge.loader.version_range=2 UNSET\n\n# Load before - if present our mod will load before these.\n# format of mod1 mod2 mod3 ...\ndeps.before = UNSET\n\n# Controls publishing automation\n# Set to false when publishing for real.\npublish.dry_run = true\n# Leaving this field unset will use the mc_min value.\n# To specify versions use the format ver1 ver2 ver3 ...\npublish.acceptable_mc_versions = UNSET\npublish.token.modrinth = UNSET\npublish.token.curseforge = UNSET\n# You must also have the credentials stored in Environment Variables.\n# The environment vars are MVN_NAME and MVN_PASSWORD\npublish.maven.url = UNSET","settings.gradle.kts":"pluginManagement {\n    repositories {\n        gradlePluginPortal()\n        mavenCentral()\n        maven(\"https://maven.fabricmc.net/\")\n        maven(\"https://maven.architectury.dev\")\n        maven(\"https://maven.minecraftforge.net/\")\n        maven(\"https://maven.neoforged.net/releases/\")\n        maven(\"https://repo.spongepowered.org/maven\")\n        maven(\"https://maven.kikugie.dev/snapshots\")\n        maven(\"https://maven.kikugie.dev/releases\")\n    }\n    plugins {\n        kotlin(\"jvm\") version \"2.2.0\"\n        id(\"org.gradle.toolchains.foojay-resolver-convention\") version \"1.0.0\"\n    }\n}\n\nplugins {\n    id(\"dev.kikugie.stonecutter\") version \"0.7.10\"\n    id(\"org.gradle.toolchains.foojay-resolver-convention\") version \"1.0.0\"\n}\n\nstonecutter {\n    kotlinController = true\n    centralScript = \"build.gradle.kts\"\n\n    create(rootProject) {\n        fun ver(\n            mcVersion: String,\n            vararg loaders: String,\n        ) {\n            for (loader in loaders) {\n                version(\"$mcVersion-$loader\", mcVersion)\n            }\n        }\n        // $start stonecutter-versions\n        // $end stonecutter-versions\n        // $start stonecutter-vcs\n        // $end stonecutter-vcs\n    }\n}\n\nrootProject.name = extra[\"mod.id\"] as String\n",".github":{"workflows":{"build.yml":"name: Build Minecraft Mod\n\non:\n  push:\n    branches:\n      - main\n  release:\n    types: [published]\n\nenv:\n  JAVA_VERSION: '21'\n  GRADLE_BUILD_TASK: 'build'\n  ARTIFACT_STAGING_DIR: './artifacts_to_upload'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout Repository\n        uses: actions/checkout@v4\n\n      - name: Setup Java\n        uses: actions/setup-java@v4\n        with:\n          distribution: 'temurin'\n          java-version: ${{ env.JAVA_VERSION }}\n          cache: 'gradle'\n\n      - name: Grant Execute Permissions for Gradle Wrapper\n        run: chmod +x gradlew\n\n      - name: Build Mod\n        run: ./gradlew ${{ env.GRADLE_BUILD_TASK }}\n\n      - name: Create Staging Directory\n        run: mkdir -p ${{ env.ARTIFACT_STAGING_DIR }}\n\n      - name: Collect and Rename JARs\n        run: |\n          find versions -type f -path \"*/build/libs/*.jar\" \\\n            ! -name \"*-sources.jar\" \\\n            ! -name \"*-javadoc.jar\" | while read -r jar_path; do\n\n            mc_version=$(echo \"$jar_path\" | sed -n 's|versions/\\([^/]*\\)/.*|\\1|p')\n\n            original_filename=$(basename \"$jar_path\")\n\n            new_filename=\"${mc_version}-${original_filename}\"\n\n            echo \"Renaming '$original_filename' (from MC $mc_version) to '$new_filename'\"\n\n            # Copy and rename to the staging directory\n            cp \"$jar_path\" \"${{ env.ARTIFACT_STAGING_DIR }}/$new_filename\"\n          done\n\n      - name: List Staged Files\n        run: ls -l ${{ env.ARTIFACT_STAGING_DIR }}\n\n      - name: Upload JARs\n        uses: actions/upload-artifact@v4\n        with:\n          name: mod-jars\n          path: ${{ env.ARTIFACT_STAGING_DIR }}/\n          retention-days: 7\n\n  release:\n    if: github.event_name == 'release' && github.event.action == 'published'\n    runs-on: ubuntu-latest\n    needs: build\n\n    steps:\n      - name: Download JARs\n        uses: actions/download-artifact@v4\n        with:\n          name: mod-jars\n\n      - name: List Downloaded Files\n        run: ls -R\n\n      - name: Create Release\n        id: create_release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: \"*.jar\"\n          prerelease: ${{ contains(github.ref_name, 'beta') || contains(github.ref_name, 'rc') }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}"}},"src":{"main":{"resources":{"example_mod.accesswidener":"accessWidener v2 named\naccessible field net/minecraft/client/gui/screen/Screen client Lnet/minecraft/client/MinecraftClient;","mixins.example_mod.json":"{\n  \"required\": true,\n  \"minVersion\": \"0.8\",\n  \"package\": \"com.author.example_mod.mixins\",\n  \"compatibilityLevel\": \"JAVA_${java_version}\",\n  \"mixins\": [],\n  \"client\": [\n    \"$if mappings-yarn\",\n    \"TitleScreenMixin\",\n    \"$end mappings-yarn\"\n  ],\n  \"injectors\": {\n    \"defaultRequire\": 1\n  },\n  \"overwrites\": {\n    \"requireAnnotations\": true\n  }\n}","mixins.neoforge.example_mod.json":"{\n  \"required\": true,\n  \"minVersion\": \"0.8\",\n  \"package\": \"com.author.example_mod.neoforge.mixins\",\n  \"compatibilityLevel\": \"JAVA_${java_version}\",\n  \"mixins\": [],\n  \"client\": [],\n  \"injectors\": {\n    \"defaultRequire\": 1\n  },\n  \"overwrites\": {\n    \"requireAnnotations\": true\n  }\n}","mixins.forge.example_mod.json":"{\n  \"required\": true,\n  \"minVersion\": \"0.8\",\n  \"package\": \"com.author.example_mod.forge.mixins\",\n  \"compatibilityLevel\": \"JAVA_${java_version}\",\n  \"mixins\": [],\n  \"client\": [],\n  \"injectors\": {\n    \"defaultRequire\": 1\n  },\n  \"overwrites\": {\n    \"requireAnnotations\": true\n  }\n}","pack.mcmeta":"{\n  \"pack\": {\n    \"description\": \"${modid} resources\",\n    \"pack_format\": ${pack_format},\n    \"forge:server_data_pack_format\": 12\n  }\n}","data":{"minecraft":{"tags":{"block":{"TODO.json":"TODO DELETE ME!"}}},"example_mod":{"tags":{"item":{"TODO.json":"TODO DELETE ME!"}},"recipe":{"TODO.json.json":"TODO DELETE ME!"},"loot_table":{"TODO.json":"TODO DELETE ME!"}}},"mixins.fabric.example_mod.json":"{\n  \"required\": true,\n  \"minVersion\": \"0.8\",\n  \"package\": \"com.author.example_mod.fabric.mixins\",\n  \"compatibilityLevel\": \"JAVA_${java_version}\",\n  \"mixins\": [],\n  \"client\": [],\n  \"injectors\": {\n    \"defaultRequire\": 1\n  },\n  \"overwrites\": {\n    \"requireAnnotations\": true\n  }\n}","META-INF":{"neoforge.mods.toml":"#[[accessTransformers]]\n#file=\"META-INF/accesstransformer.cfg\"\n# The coremods config file path is not configurable and is always loaded from META-INF/coremods.json\n\nmodLoader=\"javafml\"\nloaderVersion=\"${forgelike_loader_ver}\"\nlicense=\"${license}\"\nissueTrackerURL=\"${issue_tracker}\"\n\n[[mods]]\nmodId=\"${id}\"\nversion=\"${version}\"\ndisplayName=\"${name}\"\nlogoFile=\"${icon}\"\nauthors=\"${authors}\"\ndescription='''\n${description}\n'''\n\n${mixin_field}\n\n${dependencies_field}\n\n","mods.toml":"modLoader=\"javafml\"\nloaderVersion=\"${forgelike_loader_ver}\"\nlicense=\"${license}\"\nissueTrackerURL=\"${issue_tracker}\"\n\n[[mods]]\nmodId=\"${id}\"\nversion=\"${version}\"\ndisplayName=\"${name}\"\nlogoFile=\"${icon}\"\nauthors=\"${authors}\"\ndescription='''\n${description}\n'''\n\n${mixin_field}\n\n${dependencies_field}\n"},"fabric.mod.json":"{\n  \"schemaVersion\": 1,\n  \"id\": \"${id}\",\n  \"version\": \"${version}\",\n  \"name\": \"${name}\",\n  \"description\": \"${description}\",\n  \"authors\": [\n    \"${authors}\"\n  ],\n  \"contact\": {\n    \"homepage\": \"${website}\",\n    \"sources\": \"${source_url}\",\n    \"issues\": \"${issue_tracker}\"\n  },\n  \"license\": \"${license}\",\n  \"icon\": \"${icon}\",\n  \"environment\": \"*\",\n  \"entrypoints\": {\n    \"main\": [\n      \"${fabric_common_entry}\"\n    ],\n    \"client\": [\n      \"${fabric_client_entry}\"\n    ]\n  },\n${mixin_field}\n${dependencies_field}\n}"},"java":{"com":{"author":{"example_mod":{"common":{"ExampleModCommon.java":"package com.author.example_mod.common;\n\nimport com.author.example_mod.Compat;\n//? if neoforge {\n/*import net.neoforged.fml.ModContainer;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.fml.event.lifecycle.FMLCommonSetupEvent;\n*///?} else if forge {\n/*import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\nimport net.minecraftforge.eventbus.api.IEventBus;\nimport net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;\n*///?}\n\n/**\n * This is the entry point for your mod's common side, called by each modloader specific side.\n */\npublic class ExampleModCommon {\n    //? if fabric {\n    public static void init() {\n    //?} else if neoforge {\n    /*public static void init(FMLCommonSetupEvent event, IEventBus eventBus, ModContainer modContainer) {\n    *///?} else if forge {\n    /*public static void init(FMLCommonSetupEvent event, IEventBus eventBus, FMLJavaModLoadingContext context) {\n    *///?}\n        Compat.LOGGER.info(\"Hello from the common side!\");\n    }\n}\n"},"fabric":{"ExampleModFabricClient.java":"//? if fabric {\npackage com.author.example_mod.fabric;\n\nimport net.fabricmc.api.ClientModInitializer;\nimport com.author.example_mod.client.ExampleModClient;\n\npublic class ExampleModFabricClient implements ClientModInitializer {\n    @Override\n    public void onInitializeClient() {\n        ExampleModClient.init();\n    }\n}\n//?}\n","ExampleModFabricCommon.java":"//? if fabric {\npackage com.author.example_mod.fabric;\n\nimport net.fabricmc.api.ModInitializer;\nimport com.author.example_mod.common.ExampleModCommon;\n\npublic class ExampleModFabricCommon implements ModInitializer {\n    @Override\n    public void onInitialize() {\n        ExampleModCommon.init();\n    }\n}\n//?}"},"forge":{"ExampleModForge.java":"//? if forge {\n/*package com.author.example_mod.forge;\n\nimport com.author.example_mod.client.ExampleModClient;\nimport net.minecraftforge.eventbus.api.IEventBus;\nimport net.minecraftforge.fml.common.Mod;\nimport com.author.example_mod.common.ExampleModCommon;\nimport net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;\nimport net.minecraftforge.fml.event.lifecycle.FMLCommonSetupEvent;\nimport net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\n\n@Mod(/^$ mod_id_string {^/\"example_mod\"/^$}^/)\npublic class ExampleModForge {\n    public ExampleModForge() {\n        FMLJavaModLoadingContext context = FMLJavaModLoadingContext.get();\n        IEventBus eventBus = context.getModEventBus();\n\n        eventBus.addListener((final FMLClientSetupEvent event) -> ExampleModClient.init(event, eventBus, context));\n        eventBus.addListener((final FMLCommonSetupEvent event) -> ExampleModCommon.init(event, eventBus, context));\n    }\n}\n*///?}\n"},"client":{"ExampleModClient.java":"package com.author.example_mod.client;\n\nimport com.author.example_mod.Compat;\n//? if neoforge {\n/*import net.neoforged.fml.ModContainer;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.fml.event.lifecycle.FMLClientSetupEvent;\n*///?} else if forge {\n/*import net.minecraftforge.fml.javafmlmod.FMLJavaModLoadingContext;\nimport net.minecraftforge.eventbus.api.IEventBus;\nimport net.minecraftforge.fml.event.lifecycle.FMLClientSetupEvent;\n*///?}\n\n/**\n * This is the entry point for your mod's client side, called by each modloader specific side.\n */\npublic class ExampleModClient {\n    //? if fabric {\n    public static void init() {\n    //?} else if neoforge {\n    /*public static void init(FMLClientSetupEvent event, IEventBus eventBus, ModContainer modContainer) {\n    *///?} else if forge {\n    /*public static void init(FMLClientSetupEvent event, IEventBus eventBus, FMLJavaModLoadingContext context) {\n    *///?}\n        Compat.LOGGER.info(\"Hello from the client side!\");\n    }\n}\n"},"mixins":{"TitleScreenMixin.java":"package com.author.example_mod.mixins;\n\nimport com.author.example_mod.Compat;\nimport net.minecraft.client.gui.screen.TitleScreen;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\n\n@Mixin(TitleScreen.class)\npublic class TitleScreenMixin {\n    @Inject(method = \"init\", at = @At(\"HEAD\"))\n    public void initMixinExample(CallbackInfo ci) {\n        String baseString = \"Hello from %LOADER% on Minecraft %VERSION%\";\n\n        /// https://stonecutter.kikugie.dev/stonecutter/guide/comments\n        String loader =  /*$ loader_string {*/\"fabric\"/*$}*/;\n        String version = /*$ minecraft_version_string {*/\"1.21.8\"/*$}*/;\n\n        baseString = baseString.replace(\"%LOADER%\",loader);\n        baseString = baseString.replace(\"%VERSION%\",version);\n\n        Compat.LOGGER.info(baseString);\n\n        TitleScreen titleScreen = (TitleScreen) (Object) this;\n\n        if (titleScreen.client != null) {\n            Compat.LOGGER.info(\"Manually exiting\");\n            titleScreen.client.scheduleStop();\n        }\n    }\n}"},"Compat.java":"package com.author.example_mod;\n\n//? if (forge && <= 1.18) || <= 1.16.5 {\n/*import org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.LogManager;\n*///?} else {\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n//?}\n\npublic class Compat {\n    //? if (forge && <= 1.18) || <= 1.16.5 {\n    /*public static final Logger LOGGER = LogManager.getLogger(/^$ mod_id_string {^/\"example_mod\"/^$}^/);\n     *///?} else {\n    public static final Logger LOGGER = LoggerFactory.getLogger(/*$ mod_id_string {*/\"example_mod\"/*$}*/);\n    //?}\n}\n","neoforge":{"ExampleModNeoforge.java":"//? if neoforge {\n/*package com.author.example_mod.neoforge;\n\nimport com.author.example_mod.client.ExampleModClient;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.fml.ModContainer;\nimport net.neoforged.fml.common.Mod;\nimport com.author.example_mod.common.ExampleModCommon;\nimport net.neoforged.fml.event.lifecycle.FMLClientSetupEvent;\nimport net.neoforged.fml.event.lifecycle.FMLCommonSetupEvent;\n\n@Mod(/^$ mod_id_string {^/\"example_mod\"/^$}^/)\npublic class ExampleModNeoforge {\n    public ExampleModNeoforge(IEventBus eventBus, ModContainer modContainer) {\n        eventBus.addListener((final FMLClientSetupEvent event) -> ExampleModClient.init(event, eventBus, modContainer));\n        eventBus.addListener((final FMLCommonSetupEvent event) -> ExampleModCommon.init(event, eventBus, modContainer));\n    }\n}\n*///?}"}}}}}}},".envrc":"use flake","flake.nix":"{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-25.05\";\n    flake-parts.url = \"github:hercules-ci/flake-parts\";\n    systems.url = \"github:nix-systems/default\";\n  };\n\n  outputs = inputs:\n    inputs.flake-parts.lib.mkFlake {inherit inputs;} {\n      systems = import inputs.systems;\n\n      perSystem = {\n        config,\n        self',\n        pkgs,\n        lib,\n        system,\n        ...\n      }: let\n        java = pkgs.jetbrains.jdk-no-jcef;\n\n        nativeBuildInputs = with pkgs; [\n          java\n          git\n        ];\n\n        buildInputs = with pkgs; [\n          libGL\n          glfw-wayland-minecraft\n          flite\n          libpulseaudio\n        ];\n      in {\n        devShells.default = pkgs.mkShell {\n          inherit nativeBuildInputs buildInputs;\n\n          env = {\n            LD_LIBRARY_PATH = lib.makeLibraryPath buildInputs;\n            JAVA_HOME = \"${java.home}\";\n          };\n        };\n      };\n    };\n}\n","build.gradle.kts":"import java.util.*\nimport java.util.Optional\nimport java.util.function.BiConsumer\nimport java.util.function.Consumer\nimport java.util.function.Predicate\n\nplugins {\n    `maven-publish`\n    kotlin(\"jvm\") version \"2.2.0\"\n    id(\"dev.architectury.loom\") version \"1.11-SNAPSHOT\"\n    id(\"me.modmuss50.mod-publish-plugin\")\n}\n\nrepositories {\n    mavenCentral()\n    exclusiveContent {\n        forRepository { maven(\"https://www.cursemaven.com\") { name = \"CurseForge\" } }\n        filter { includeGroup(\"curse.maven\") }\n    }\n    exclusiveContent {\n        forRepository { maven(\"https://api.modrinth.com/maven\") { name = \"Modrinth\" } }\n        filter { includeGroup(\"maven.modrinth\") }\n    }\n    maven(\"https://maven.neoforged.net/releases/\")\n    maven(\"https://maven.architectury.dev/\")\n    maven(\"https://modmaven.dev/\")\n    maven(\"https://panel.ryuutech.com/nexus/repository/maven-releases/\")\n}\n\nfun bool(str: String): Boolean = str.lowercase().startsWith(\"t\")\n\nfun boolProperty(key: String): Boolean {\n    if (!hasProperty(key)) {\n        return false\n    }\n    return bool(property(key).toString())\n}\n\nfun listProperty(key: String): ArrayList<String> {\n    if (!hasProperty(key)) {\n        return arrayListOf()\n    }\n    val str = property(key).toString()\n    if (str == \"UNSET\") {\n        return arrayListOf()\n    }\n    return ArrayList(str.split(\" \"))\n}\n\nfun optionalStrProperty(key: String): Optional<String> {\n    if (!hasProperty(key)) {\n        return Optional.empty()\n    }\n    val str = property(key).toString()\n    if (str == \"UNSET\") {\n        return Optional.empty()\n    }\n    return Optional.of(str)\n}\n\nclass VersionRange(\n    val min: String,\n    val max: String,\n) {\n    fun asForgelike(): String = \"${if (min.isEmpty()) \"(\" else \"[\"}$min,${max}${if (max.isEmpty()) \")\" else \"]\"}\"\n\n    fun asFabric(): String {\n        var out = \"\"\n        if (min.isNotEmpty()) {\n            out += \">=$min\"\n        }\n        if (max.isNotEmpty()) {\n            if (out.isNotEmpty()) {\n                out += \" \"\n            }\n            out += \"<=$max\"\n        }\n        return out\n    }\n}\n\nfun versionProperty(key: String): VersionRange {\n    if (!hasProperty(key)) {\n        return VersionRange(\"\", \"\")\n    }\n    val list = listProperty(key)\n    for (i in 0 until list.size) {\n        if (list[i] == \"UNSET\") {\n            list[i] = \"\"\n        }\n    }\n    return if (list.isEmpty()) {\n        VersionRange(\"\", \"\")\n    } else if (list.size == 1) {\n        VersionRange(list[0], \"\")\n    } else {\n        VersionRange(list[0], list[1])\n    }\n}\n\n/**\n * Creates a VersionRange unless the value is UNSET\n */\nfun optionalVersionProperty(key: String): Optional<VersionRange> {\n    val str = optionalStrProperty(key)\n    if (!hasProperty(key)) {\n        return Optional.empty()\n    }\n    if (!str.isPresent) {\n        return Optional.empty()\n    }\n    return Optional.of(versionProperty(key))\n}\n\nval envFile = project.rootDir.resolve(\".env\")\nval properties = Properties()\nif (envFile.exists()) {\n    logger.lifecycle(\"Loading .env file from: ${envFile.absolutePath}\")\n    envFile.bufferedReader().use { reader ->\n        properties.load(reader)\n    }\n} else {\n    logger.lifecycle(\".env file not found at: ${envFile.absolutePath}. Defaulting to production mode.\")\n}\n\nval isInDevMode: Boolean = properties.getProperty(\"IS_DEV_MODE\")?.toBoolean() ?: false\n\nenum class EnvType {\n    FABRIC,\n    FORGE,\n    NEOFORGE,\n}\n\n/**\n * Stores core dependency and environment information.\n */\nclass Env {\n    val archivesBaseName: String = optionalStrProperty(\"archives_base_name\").orElse(property(\"mod.id\").toString())\n\n    val mcVersion = versionProperty(\"deps.core.mc.version_range\")\n\n    val loader = property(\"loom.platform\").toString()\n    // $start stonecutter-mapper\n    val mapper = \"yarn\"\n    // $end stonecutter-mapper\n    val isFabric = loader == \"fabric\"\n    val isForge = loader == \"forge\"\n    val isNeo = loader == \"neoforge\"\n    val isCommon = project.parent!!.name == \"common\"\n    val isApi = project.parent!!.name == \"api\"\n    val packFormat = property(\"deps.pack_format\")\n    val type =\n        if (isFabric) {\n            EnvType.FABRIC\n        } else if (isForge) {\n            EnvType.FORGE\n        } else {\n            EnvType.NEOFORGE\n        }\n\n    val javaVersion =\n        if (atMost(\"1.16.5\")) {\n            8\n        } else if (isExact(\"1.17.1\")) {\n            16\n        } else if (atMost(\"1.20.4\")) {\n            17\n        } else {\n            21\n        }\n\n    val fabricLoaderVersion = versionProperty(\"deps.core.fabric.loader.version_range\")\n    val forgeMavenVersion = versionProperty(\"deps.core.forge.version_range\")\n    val forgeVersion = VersionRange(extractForgeVer(forgeMavenVersion.min), extractForgeVer(forgeMavenVersion.max))\n\n    // FML language version is usually the first two numbers only.\n    private val fgl: String = if (isForge) forgeMavenVersion.min.substring(forgeMavenVersion.min.lastIndexOf(\"-\")) else \"\"\n    val forgeLanguageVersion = VersionRange(if (isForge) fgl.substring(0, fgl.indexOf(\".\")) else \"\", \"\")\n    val neoforgeVersion = versionProperty(\"deps.core.neoforge.version_range\")\n\n    // The modloader system is separate from the API in Neo\n    val neoforgeLoaderVersion = versionProperty(\"deps.core.neoforge.loader.version_range\")\n\n    fun atLeast(version: String) = stonecutter.compare(mcVersion.min, version) >= 0\n\n    fun atMost(version: String) = stonecutter.compare(mcVersion.min, version) <= 0\n\n    fun isNot(version: String) = stonecutter.compare(mcVersion.min, version) != 0\n\n    fun isExact(version: String) = stonecutter.compare(mcVersion.min, version) == 0\n\n    private fun extractForgeVer(str: String): String {\n        val split = str.split(\"-\")\n        if (split.size == 1) {\n            return split[0]\n        }\n        if (split.size > 1) {\n            return split[1]\n        }\n        return \"\"\n    }\n}\nval env = Env()\n\n// In dev mode all dependencies will run in INCLUDE mode for convenience.\nenum class DepType {\n    API,\n\n    // Optional API\n    API_OPTIONAL {\n        override fun isOptional(): Boolean = true\n    },\n\n    // Implementation\n    IMPL,\n\n    // Forge Runtime Library\n    FRL {\n        override fun includeInDepsList(): Boolean = false\n    },\n\n    // Implementation and Included in output jar.\n    INCLUDE {\n        override fun includeInDepsList(): Boolean = false\n    }, ;\n\n    open fun isOptional(): Boolean = false\n\n    open fun includeInDepsList(): Boolean = true\n}\n\nclass APIModInfo(\n    val modid: String?,\n    val curseSlug: String?,\n    val rinthSlug: String?,\n) {\n    constructor () : this(null, null, null)\n    constructor (modid: String) : this(modid, modid, modid)\n    constructor (modid: String, slug: String) : this(modid, slug, slug)\n}\n\n/**\n * APIs must have a maven source.\n * If the version range is not present then the API will not be used.\n * If modid is null then the API will not be declared as a dependency in uploads.\n * The enable condition determines whether the API will be used for this version.\n */\nclass APISource(\n    private val realType: DepType,\n    val modInfo: APIModInfo,\n    val mavenLocation: String,\n    val versionRange: Optional<VersionRange>,\n    private val enableCondition: Predicate<APISource>,\n) {\n    val type = if (isInDevMode) { DepType.INCLUDE } else { this.realType }\n    val enabled = this.enableCondition.test(this)\n}\n\nval apis =\n    arrayListOf(\n        // $start dependencies\n        // $end dependencies\n    )\n\n// Stores information about the mod itself.\nclass ModProperties {\n    val id = property(\"mod.id\").toString()\n    val displayName = property(\"mod.display_name\").toString()\n    val className = property(\"mod.class_name\").toString()\n    val version = property(\"version\").toString()\n    val description: String = optionalStrProperty(\"mod.description\").orElse(\"\")\n    val authors = property(\"mod.authors\").toString()\n    val icon = property(\"mod.icon\").toString()\n    val issueTracker: String = optionalStrProperty(\"mod.issue_tracker\").orElse(\"\")\n    val license: String = optionalStrProperty(\"mod.license\").orElse(\"\")\n    val sourceUrl: String = optionalStrProperty(\"mod.source_url\").orElse(\"\")\n    val generalWebsite: String = optionalStrProperty(\"mod.general_website\").orElse(sourceUrl)\n    val longVersion = \"$version+${env.mcVersion.min}+${env.loader}\"\n    val group: String = optionalStrProperty(\"group\").orElse(\"com.${authors.lowercase().replace(\"[^a-zA-Z]\".toRegex(), \"\")}\")\n    val fileName = \"$id-$longVersion.jar\"\n}\n\n/**\n * Provides access to the mixins for specific environments.\n * All environments are provided the vanilla mixin if it is enabled.\n */\nclass ModMixins {\n    private val enableVanillaMixin: Boolean = boolProperty(\"mixins.vanilla.enable\")\n    private val enableFabricMixin: Boolean = boolProperty(\"mixins.fabric.enable\")\n    private val enableForgeMixin: Boolean = boolProperty(\"mixins.forge.enable\")\n    private val enableNeoforgeMixin: Boolean = boolProperty(\"mixins.neoforge.enable\")\n\n    private val vanillaMixin: String = \"mixins.${mod.id}.json\"\n    private val fabricMixin: String = \"mixins.fabric.${mod.id}.json\"\n    private val forgeMixin: String = \"mixins.forge.${mod.id}.json\"\n    private val neoForgeMixin: String = \"mixins.neoforge.${mod.id}.json\"\n    val extraMixins: Collection<String> = listProperty(\"mixins.extras\")\n\n    /**\n     * Modify this method if you need better control over the mixin list.\n     */\n    fun getMixins(env: EnvType): List<String> {\n        val out = arrayListOf<String>()\n        if (enableVanillaMixin) out.add(vanillaMixin)\n        when (env) {\n            EnvType.FABRIC -> if (enableFabricMixin) out.add(fabricMixin)\n            EnvType.FORGE -> if (enableForgeMixin) out.add(forgeMixin)\n            EnvType.NEOFORGE -> if (enableNeoforgeMixin) out.add(neoForgeMixin)\n        }\n        return out\n    }\n}\n\n/**\n * Controls publishing. For publishing to work dryRunMode must be false.\n * Modrinth and Curseforge project tokens are publicly accessible, so it is safe to include them in files.\n * Do not include your API keys in your project!\n *\n * The Modrinth API token should be stored in the MODRINTH_TOKEN environment variable.\n * The curseforge API token should be stored in the CURSEFORGE_TOKEN environment variable.\n */\nclass ModPublish {\n    private val mcTargets = arrayListOf<String>()\n    val modrinthProjectToken = property(\"publish.token.modrinth\").toString()\n    val curseforgeProjectToken = property(\"publish.token.curseforge\").toString()\n    val mavenURL = optionalStrProperty(\"publish.maven.url\")\n    val dryRunMode = boolProperty(\"publish.dry_run\")\n\n    init {\n        val tempMcTargets = listProperty(\"publish_acceptable_mc_versions\")\n        if (tempMcTargets.isEmpty()) {\n            mcTargets.add(env.mcVersion.min)\n        } else {\n            mcTargets.addAll(tempMcTargets)\n        }\n    }\n}\nval modPublish = ModPublish()\n\n/**\n * These dependencies will be added to the fabric.mods.json, META-INF/neoforge.mods.toml, and META-INF/mods.toml file.\n */\nclass ModDependencies {\n    private val loadBefore = listProperty(\"deps.before\")\n\n    fun forEachAfter(cons: BiConsumer<String, VersionRange>) {\n        forEachRequired(cons)\n        forEachOptional(cons)\n    }\n\n    fun forEachBefore(cons: Consumer<String>) {\n        loadBefore.forEach(cons)\n    }\n\n    fun forEachOptional(cons: BiConsumer<String, VersionRange>) {\n        apis.forEach { src ->\n            if (src.enabled && src.type.isOptional() &&\n                src.type.includeInDepsList()\n            ) {\n                src.versionRange.ifPresent { ver ->\n                    src.modInfo.modid?.let {\n                        cons.accept(it, ver)\n                    }\n                }\n            }\n        }\n    }\n\n    fun forEachRequired(cons: BiConsumer<String, VersionRange>) {\n        cons.accept(\"minecraft\", env.mcVersion)\n        if (env.isForge) {\n            cons.accept(\"forge\", env.forgeVersion)\n        }\n        if (env.isNeo) {\n            cons.accept(\"neoforge\", env.neoforgeVersion)\n        }\n        if (env.isFabric) {\n            cons.accept(\"fabric\", env.fabricLoaderVersion)\n        }\n        apis.forEach { src ->\n            if (src.enabled && !src.type.isOptional() &&\n                src.type.includeInDepsList()\n            ) {\n                src.versionRange.ifPresent { ver ->\n                    src.modInfo.modid?.let {\n                        cons.accept(it, ver)\n                    }\n                }\n            }\n        }\n    }\n}\nval dependencies = ModDependencies()\n\n/**\n * These values will change between versions and mod loaders. Handles generation of specific entries in mods.toml and neoforge.mods.toml\n */\nclass SpecialMultiversionedConstants {\n    private val mandatoryIndicator = if (env.isNeo && !env.atMost(\"1.20.2\")) \"required\" else \"mandatory\"\n    val mixinField =\n        if (env.isNeo) {\n            neoForgeMixinField()\n        } else if (env.isFabric) {\n            fabricMixinField()\n        } else {\n            \"\"\n        }\n\n    val forgelikeLoaderVer = if (env.isForge) env.forgeLanguageVersion.asForgelike() else env.neoforgeLoaderVersion.asForgelike()\n    val forgelikeAPIVer = if (env.isForge) env.forgeVersion.asForgelike() else env.neoforgeVersion.asForgelike()\n    val dependenciesField = if (env.isFabric) fabricDependencyList() else forgelikeDependencyField()\n    val excludes = excludes0()\n\n    private fun excludes0(): List<String> {\n        val out = arrayListOf<String>()\n        if (!env.isForge) {\n            // NeoForge before 1.20.5 still uses the forge mods.toml :/ One of those goofy changes between versions.\n            if (!env.isNeo || !env.atMost(\"1.20.4\")) {\n                out.add(\"META-INF/mods.toml\")\n            }\n        }\n        if (!env.isFabric) {\n            out.add(\"fabric.mod.json\")\n        }\n        if (!env.isNeo || env.atMost(\"1.20.4\")) {\n            out.add(\"META-INF/neoforge.mods.toml\")\n        }\n        return out\n    }\n\n    private fun neoForgeMixinField(): String {\n        var out = \"\"\n        for (mixin in modMixins.getMixins(EnvType.NEOFORGE)) {\n            out += \"[[mixins]]\\nconfig=\\\"${mixin}\\\"\\n\"\n        }\n        return out\n    }\n\n    private fun fabricMixinField(): String {\n        val list = modMixins.getMixins(EnvType.FABRIC)\n        if (list.isEmpty()) {\n            return \"\"\n        } else {\n            var out = \"  \\\"mixins\\\" : [\\n\"\n            for ((index, mixin) in list.withIndex()) {\n                out += \"    \\\"${mixin}\\\"\"\n                if (index < list.size - 1) {\n                    out += \",\"\n                }\n                out += \"\\n\"\n            }\n            return \"$out  ],\"\n        }\n    }\n\n    private fun fabricDependencyList(): String {\n        var out = \"  \\\"depends\\\":{\"\n        var useComma = false\n        dependencies.forEachRequired { modid, ver ->\n            if (useComma) {\n                out += \",\"\n            }\n            out += \"\\n\"\n            out += \"    \\\"${modid}\\\": \\\"${ver.asFabric()}\\\"\"\n            useComma = true\n        }\n        return \"$out\\n  }\"\n    }\n\n    private fun forgelikeDependencyField(): String {\n        var out = \"\"\n        dependencies.forEachBefore { modid ->\n            out += forgeDep(modid, VersionRange(\"\", \"\"), \"BEFORE\", false)\n        }\n        dependencies.forEachOptional { modid, ver ->\n            out += forgeDep(modid, ver, \"AFTER\", false)\n        }\n        dependencies.forEachRequired { modid, ver ->\n            out += forgeDep(modid, ver, \"AFTER\", true)\n        }\n        return out\n    }\n\n    private fun forgeDep(\n        modid: String,\n        versionRange: VersionRange,\n        order: String,\n        mandatory: Boolean,\n    ): String =\n        \"[[dependencies.${mod.id}]]\\n\" +\n            \"modId=\\\"${modid}\\\"\\n\" +\n            \"$mandatoryIndicator=${mandatory}\\n\" +\n            \"versionRange=\\\"${versionRange.asForgelike()}\\\"\\n\" +\n            \"ordering=\\\"${order}\\\"\\n\" +\n            \"side=\\\"BOTH\\\"\\n\"\n}\nval mod = ModProperties()\nval modMixins = ModMixins()\nval dynamics = SpecialMultiversionedConstants()\n\nversion = mod.longVersion\ngroup = mod.group\n\n// Adds both optional and required dependencies to stonecutter version checking.\ndependencies.forEachAfter { mid, ver ->\n    stonecutter.dependencies[mid] = ver.min\n}\napis.forEach { src ->\n    src.modInfo.modid?.let {\n        stonecutter.constants.put(it, src.enabled)\n        src.versionRange.ifPresent { ver ->\n            stonecutter.dependencies[it] = ver.min\n        }\n    }\n}\n\nstonecutter {\n    val map =\n        mapOf(\n            \"mod_id\" to mod.id,\n            \"mod_name\" to mod.displayName,\n            \"authors\" to mod.authors,\n            \"mod_description\" to mod.description,\n            \"mod_website\" to mod.generalWebsite,\n            \"mod_source\" to mod.sourceUrl,\n            \"mod_issues\" to mod.issueTracker,\n            \"mod_group\" to mod.group,\n            \"mod.icon\" to mod.icon,\n            \"mod_license\" to mod.license,\n            \"mod_version\" to mod.version,\n            \"minecraft_version\" to env.mcVersion.min,\n            \"loader\" to env.loader,\n            \"java_version\" to env.javaVersion.toString(),\n        )\n\n    fun swap(\n        name: String,\n        value: String,\n    ) {\n        swaps[\"${name}_string\"] = \"\\\"${value}\\\"\"\n        swaps[name] = value\n    }\n\n    for (entry in map) {\n        swap(entry.key, entry.value)\n    }\n\n    constants.match(\n        env.loader,\n        \"fabric\",\n        \"neoforge\",\n        \"forge\",\n    )\n\n    constants.match(\n        env.mapper,\n        \"mojmaps\",\n        \"parchment\",\n        \"yarn\",\n    )\n\n    constants.put(\"fabric\", env.isFabric)\n    constants.put(\"forge\", env.isForge)\n    constants.put(\"neoforge\", env.isNeo)\n\n    constants.put(\"dev_mode\", isInDevMode)\n}\n\nloom {\n    accessWidenerPath = file(\"../../src/main/resources/example_mod.accesswidener\")\n\n    silentMojangMappingsLicense()\n    if (env.isForge) {\n        forge {\n            for (mixin in modMixins.getMixins(EnvType.FORGE)) {\n                mixinConfigs(\n                    mixin,\n                )\n            }\n        }\n    }\n\n    decompilers {\n        get(\"vineflower\").apply {\n            // Adds names to lambdas - useful for mixins\n            options.put(\"mark-corresponding-synthetics\", \"1\")\n        }\n    }\n\n    runConfigs.all {\n        ideConfigGenerated(true)\n        // Provides lots of useful mixin info, including the processed mixin files\n        vmArgs(\"-Dmixin.debug.export=true\")\n        // $if shared-runs\n        runDir = \"../../run\"\n        // $end shared-runs\n    }\n}\n\nbase { archivesName.set(env.archivesBaseName) }\n\n@Suppress(\"ktlint:standard:no-consecutive-comments\")\ndependencies {\n    minecraft(\"com.mojang:minecraft:${env.mcVersion.min}\")\n    /* $if mappings-mojmaps\n    mappings(loom.officialMojangMappings())\n       $end mappings-mojmaps */\n    /* $if mappings-parchment\n    mappings(\n        loom.layered {\n            officialMojangMappings()\n            parchment(\"org.parchmentmc.data:parchment-${env.mcVersion.min}:${property(\"deps.mappings.parchment\")}@zip\")\n        },\n    )\n       $end mappings-parchment */\n    // $if mappings-yarn\n    mappings(\n        loom.layered {\n            mappings(\"net.fabricmc:yarn:${property(\"deps.mappings.yarn\")}:v2\")\n            val patch = optionalStrProperty(\"deps.mappings.yarn.patch\")\n            if (patch.isPresent) {\n                mappings(\"dev.architectury:yarn-mappings-patch-${env.loader}:${patch.get()}\")\n            }\n        },\n    )\n    // $end mappings-yarn\n\n    if (env.isFabric) {\n        modImplementation(\"net.fabricmc:fabric-loader:${env.fabricLoaderVersion.min}\")\n    }\n    if (env.isForge) {\n        \"forge\"(\"net.minecraftforge:forge:${env.forgeMavenVersion.min}\")\n    }\n    if (env.isNeo) {\n        \"neoForge\"(\"net.neoforged:neoforge:${env.neoforgeVersion.min}\")\n    }\n\n    apis.forEach { src ->\n        if (src.enabled) {\n            src.versionRange.ifPresent { ver ->\n                if (src.type == DepType.API || src.type == DepType.API_OPTIONAL) {\n                    modApi(\"${src.mavenLocation}:${ver.min}\")\n                }\n                if (src.type == DepType.IMPL) {\n                    modImplementation(\"${src.mavenLocation}:${ver.min}\")\n                }\n                if (src.type == DepType.FRL && env.isForge) {\n                    \"forgeRuntimeLibrary\"(\"${src.mavenLocation}:${ver.min}\")\n                }\n                if (src.type == DepType.INCLUDE) {\n                    modImplementation(\"${src.mavenLocation}:${ver.min}\")\n                    include(\"${src.mavenLocation}:${ver.min}\")\n                }\n            }\n        }\n    }\n\n    vineflowerDecompilerClasspath(\"org.vineflower:vineflower:1.10.1\")\n}\n\njava {\n    withSourcesJar()\n    val java =\n        when (env.javaVersion) {\n            8 -> JavaVersion.VERSION_1_8\n            16 -> JavaVersion.VERSION_16\n            17 -> JavaVersion.VERSION_17\n            21 -> JavaVersion.VERSION_21\n            else -> throw Error(\"Unknown java version used\")\n        }\n    targetCompatibility = java\n    sourceCompatibility = java\n}\n\n/**\n * Replaces the normal copy task and post-processes the files.\n * Effectively renames datapack directories due to depluralization past 1.20.4.\n * TODO: acknowledge that you should not pluralize the directories listed in targets.\n */\n\nabstract class ProcessResourcesExtension : ProcessResources() {\n    // TODO: The modid needs setting here too sadly\n    // $start pure-id\n    private val id: String = \"example_mod\"\n    // $end pure-id\n\n    @get:Input\n    val autoPluralize =\n        arrayListOf(\n            \"/data/minecraft/tags/block\",\n            \"/data/minecraft/tags/item\",\n            \"/data/$id/loot_table\",\n            \"/data/$id/recipe\",\n            \"/data/$id/tags/item\",\n        )\n\n    override fun copy() {\n        super.copy()\n        val root = destinationDir.absolutePath\n        autoPluralize.forEach { path ->\n            val file = File(root.plus(path))\n            if (file.exists()) {\n                file.copyRecursively(File(file.absolutePath.plus(\"s\")), true)\n                file.deleteRecursively()\n            }\n        }\n    }\n}\n\nif (env.atMost(\"1.20.6\")) {\n    tasks.replace(\"processResources\", ProcessResourcesExtension::class)\n}\n\ntasks.processResources {\n    val map =\n        mapOf(\n            \"modid\" to mod.id,\n            \"id\" to mod.id,\n            \"name\" to mod.displayName,\n            \"display_name\" to mod.displayName,\n            \"version\" to mod.version,\n            \"description\" to mod.description,\n            \"authors\" to mod.authors,\n            \"github_url\" to mod.sourceUrl,\n            \"source_url\" to mod.sourceUrl,\n            \"website\" to mod.generalWebsite,\n            \"icon\" to mod.icon,\n            \"fabric_common_entry\" to \"${mod.group}.${env.archivesBaseName}.fabric.${mod.className}FabricCommon\",\n            \"fabric_client_entry\" to \"${mod.group}.${env.archivesBaseName}.fabric.${mod.className}FabricClient\",\n            \"mc_min\" to env.mcVersion.min,\n            \"mc_max\" to env.mcVersion.max,\n            \"issue_tracker\" to mod.issueTracker,\n            \"java_version\" to env.javaVersion.toString(),\n            \"forgelike_loader_ver\" to dynamics.forgelikeLoaderVer,\n            \"forgelike_api_ver\" to dynamics.forgelikeAPIVer,\n            \"loader_id\" to env.loader,\n            \"license\" to mod.license,\n            \"mixin_field\" to dynamics.mixinField,\n            \"dependencies_field\" to dynamics.dependenciesField,\n            \"pack_format\" to env.packFormat\n        )\n    inputs.properties(map)\n    dynamics.excludes.forEach { file ->\n        exclude(file)\n    }\n\n    filesMatching(\"pack.mcmeta\") { expand(map) }\n    filesMatching(\"fabric.mod.json\") { expand(map) }\n    filesMatching(\"META-INF/mods.toml\") { expand(map) }\n    filesMatching(\"META-INF/neoforge.mods.toml\") { expand(map) }\n    modMixins.getMixins(env.type).forEach { str -> filesMatching(str) { expand(map) } }\n}\n\n// Copy the created jars over to a central location, so you don't have to dig through all those folders *every time*.\ntasks.register(\"moveJars\", Copy::class) {\n    val fromFolder = layout.buildDirectory.dir(\"libs\").get()\n    from(fromFolder)\n    val toFolder = layout.projectDirectory.dir(\"../../build/libs\")\n    into(toFolder)\n    val fileName = mod.fileName\n    include(fileName)\n    doLast {\n        delete(fromFolder.file(fileName))\n        println(\"Moved $fileName from $fromFolder to $toFolder\")\n    }\n}\n\ntasks.clean {\n    delete(layout.projectDirectory.dir(\"../../build/libs\"))\n}\n\ntasks.build {\n    finalizedBy(tasks.getByName(\"moveJars\"))\n}\n\n// TODO: Enable auto-publishing.\n\n/*publishMods {\n    file = tasks.remapJar.get().archiveFile\n    additionalFiles.from(tasks.remapSourcesJar.get().archiveFile)\n    displayName = \"${mod.displayName} ${mod.version} for ${env.mcVersion.min}\"\n    version = mod.version\n    changelog = rootProject.file(\"CHANGELOG.md\").readText()\n    type = STABLE\n    modLoaders.add(env.loader)\n\n    dryRun = modPublish.dryRunMode\n\n    modrinth {\n        projectId = modPublish.modrinthProjectToken\n        // Get one here: https://modrinth.com/settings/pats, enable read, write, and create Versions ONLY!\n        accessToken = providers.environmentVariable(\"MODRINTH_TOKEN\")\n        minecraftVersions.addAll(modPublish.mcTargets)\n        apis.forEach{ src ->\n            if(src.enabled) src.versionRange.ifPresent{ ver ->\n                if(src.type.isOptional()){\n                    src.modInfo.rinthSlug?.let {\n                        optional {\n                            slug = it\n                            version = ver.min\n\n                        }\n                    }\n                }\n                else{\n                    src.modInfo.rinthSlug?.let {\n                        requires {\n                            slug = it\n                            version = ver.min\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    curseforge {\n        projectId = modPublish.curseforgeProjectToken\n        // Get one here: https://legacy.curseforge.com/account/api-tokens\n        accessToken = providers.environmentVariable(\"CURSEFORGE_TOKEN\")\n        minecraftVersions.addAll(modPublish.mcTargets)\n        apis.forEach{ src ->\n            if(src.enabled) src.versionRange.ifPresent{ ver ->\n                if(src.type.isOptional()){\n                    src.modInfo.curseSlug?.let {\n                        optional {\n                            slug = it\n                            version = ver.min\n\n                        }\n                    }\n                }\n                else{\n                    src.modInfo.curseSlug?.let {\n                        requires {\n                            slug = it\n                            version = ver.min\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n// TODO Disable if not uploading to a maven\npublishing {\n    repositories {\n        // TODO this is an example_mod of how I recommend you do this.\n        if(modPublish.mavenURL.isPresent) {\n            maven {\n                url = uri(modPublish.mavenURL.get())\n                credentials {\n                    username = System.getenv(\"MVN_NAME\")\n                    password = System.getenv(\"MVN_KEY\")\n                }\n            }\n        }\n    }\n    publications {\n        create<MavenPublication>(\"mavenJava\"){\n            groupId = project.group.toString()\n            artifactId = env.archivesBaseName\n            version = project.version.toString()\n            from(components[\"java\"])\n        }\n    }\n}*/\n",".gitignore":".gradle\nbuild/\nrun/\n!gradle/wrapper/gradle-wrapper.jar\n!**/src/main/**/build/\n!**/src/test/**/build/\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\nout/\n!**/src/main/**/out/\n!**/src/test/**/out/\n\n### Eclipse ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\nbin/\n!**/src/main/**/bin/\n!**/src/test/**/bin/\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\n*/run\n\n### VS Code ###\n.vscode/\n\n### Mac OS ###\n.DS_Store\n.idea/runConfigurations/\n\n/run\n/run/saves\n/run/**\n*/run\n/run/saves\n.idea/workspace.xml\n.env","flake.lock":"{\n  \"nodes\": {\n    \"flake-parts\": {\n      \"inputs\": {\n        \"nixpkgs-lib\": \"nixpkgs-lib\"\n      },\n      \"locked\": {\n        \"lastModified\": 1756770412,\n        \"narHash\": \"sha256-+uWLQZccFHwqpGqr2Yt5VsW/PbeJVTn9Dk6SHWhNRPw=\",\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"rev\": \"4524271976b625a4a605beefd893f270620fd751\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"hercules-ci\",\n        \"repo\": \"flake-parts\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs\": {\n      \"locked\": {\n        \"lastModified\": 1757408970,\n        \"narHash\": \"sha256-aSgK4BLNFFGvDTNKPeB28lVXYqVn8RdyXDNAvgGq+k0=\",\n        \"owner\": \"nixos\",\n        \"repo\": \"nixpkgs\",\n        \"rev\": \"d179d77c139e0a3f5c416477f7747e9d6b7ec315\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nixos\",\n        \"ref\": \"nixos-25.05\",\n        \"repo\": \"nixpkgs\",\n        \"type\": \"github\"\n      }\n    },\n    \"nixpkgs-lib\": {\n      \"locked\": {\n        \"lastModified\": 1754788789,\n        \"narHash\": \"sha256-x2rJ+Ovzq0sCMpgfgGaaqgBSwY+LST+WbZ6TytnT9Rk=\",\n        \"owner\": \"nix-community\",\n        \"repo\": \"nixpkgs.lib\",\n        \"rev\": \"a73b9c743612e4244d865a2fdee11865283c04e6\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-community\",\n        \"repo\": \"nixpkgs.lib\",\n        \"type\": \"github\"\n      }\n    },\n    \"root\": {\n      \"inputs\": {\n        \"flake-parts\": \"flake-parts\",\n        \"nixpkgs\": \"nixpkgs\",\n        \"systems\": \"systems\"\n      }\n    },\n    \"systems\": {\n      \"locked\": {\n        \"lastModified\": 1681028828,\n        \"narHash\": \"sha256-Vy1rq5AaRuLzOxct8nz4T6wlgyUR7zLU309k9mBC768=\",\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"rev\": \"da67096a3b9bf56a91d16901293e51ba5b49a27e\",\n        \"type\": \"github\"\n      },\n      \"original\": {\n        \"owner\": \"nix-systems\",\n        \"repo\": \"default\",\n        \"type\": \"github\"\n      }\n    }\n  },\n  \"root\": \"root\",\n  \"version\": 7\n}\n"}